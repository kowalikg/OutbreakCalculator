package queries

object SqlQueries {
    const val DROP_TABLES = "drop table if exists employees;\n" +
            "drop table if exists contacts;\n" +
            "drop table if exists infections;\n"

    const val QUERY_CREATE_TABLES =
            "create table Employees (employeeId integer PRIMARY KEY, \n" +
                    "\t\t\t\t\t\tfirstName varchar(50), \n" +
                    "\t\t\t\t\t\tlastName varchar(50), \n" +
                    "\t\t\t\t\t\tisInfected boolean);\n" +
                    "\n" +
                    "create table Contacts (id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,\n" +
                    "id1 integer, id2 integer,day integer);"

    val QUERY_INSERT_EMPLOYEES = { employeeFilePath: String ->
        "copy employees FROM '$employeeFilePath' DELIMITER ',' CSV HEADER;"
    }
    val QUERY_INSERT_CONTACTS = { contactFilePath: String ->
        "copy contacts (id1, id2, day) FROM '$contactFilePath' DELIMITER ',' CSV HEADER"
    }

    const val QUERY_FIND_R_BASED_ON_INFECTED = "select max(R)\n" +
            "                from ( select I, count(I) - 1 as R from( select id1 as I, id2 as J from (select * from Contacts where id1 in (select employeeId from Employees\n" +
            "                        where isInfected = true)\n" +
            "                        and id2 in (select employeeId from Employees\n" +
            "                        where isInfected = true)) as infections\n" +
            "                union\n" +
            "                select id2 as I, id1 as J from (select * from Contacts where id1 in (select employeeId from Employees\n" +
            "                where isInfected = true)\n" +
            "                and id2 in (select employeeId from Employees\n" +
            "                        where isInfected = true)) as infections\n" +
            "                ) as Infections\tgroup by I) as statistics"

    val QUERY_FIND_INCUBATION_TIMES = { day: Int ->
        " select max($day - day) as max_day from( select id1 as I, id2 as J, day from (select * from Contacts where id1 in (select employeeId from Employees\n" +
                "                        where isInfected = true)\n" +
                "                        and id2 in (select employeeId from Employees\n" +
                "                        where isInfected = true)) as infections\n" +
                "                union\n" +
                "                select id2 as I, id1 as J, day from (select * from Contacts where id1 in (select employeeId from Employees\n" +
                "                where isInfected = true)\n" +
                "                and id2 in (select employeeId from Employees\n" +
                "                        where isInfected = true)) as infections\n" +
                "                )as Infections where day != $day"
    }
    val QUERY_PREPARE_FOR_SIMULATION = { firstDay: Int ->
        "create table Infections (id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,\n" +
                "\t\t\t\t\t\t infectionFrom integer, infectionTo integer, day integer);\n" +
                "ALTER TABLE Employees \n DROP COLUMN IF EXISTS iteration;" +
                "alter table Employees add column iteration int default 0;\n" +
                "CREATE INDEX ON employees(iteration);\n" +
                "update Employees set iteration = 1\n" +
                "where isInfected = true;\n" +
                "insert into Infections (infectionFrom, infectionTo, day)\n" +
                "select null, employeeId , $firstDay from Employees where isInfected = true;"
    }

    const val FUNCTION_POSSIBLE_CONTACTS =
            "CREATE OR REPLACE FUNCTION possibleContacts(it int, c1 VARCHAR(40), c2 VARCHAR(40),\n" +
                    "\t\t\t\t\t\t\t\t\t endDay int)\n" +
                    "RETURNS table (\n" +
                    "\t\temployeeIdFrom int,\n" +
                    "\t\tisInfectedFrom boolean,\n" +
                    "\t\temployeeIdTo int,\n" +
                    "\t\tisInfectedTo boolean,\n" +
                    "\t\tdayOfInfection int\n" +
                    "\t)  AS \$\$\n" +
                    "BEGIN\n" +
                    "    return query execute format('\n" +
                    "\tselect g.employeeId as employeeIdFrom, g.isInfected as isInfectedFrom,\n" +
                    "\t\te.employeeId as employeeIdTo, e.isInfected as isInfectedTo, c.day\n" +
                    "\t\tfrom Employees g\n" +
                    "\t\tjoin Contacts c on c.%s = employeeId\n" +
                    "\t\tjoin Employees e on c.%s = e.employeeId\n" +
                    "\t\tjoin Infections i on i.infectionTo = g.employeeId\n" +
                    "\t\twhere g.iteration = %s and g.isInfected = true\n" +
                    "\t\tand c.day <= %s and c.day >= i.day + 2;', c1, c2, it, endDay);\n" +
                    "END;\n" +
                    "\$\$ LANGUAGE plpgsql;"

    const val FUNCTION_POSSIBLE_INFECTIONS = "CREATE OR REPLACE FUNCTION possibleInfections(it int, c1 VARCHAR(40), c2 VARCHAR(40),\n" +
            "\t\t\t\t\t\t\t\t\t  endDay int, r int)\n" +
            "RETURNS table (\n" +
            "\t\temployeeIdFrom int,\n" +
            "\t\tisInfectedFrom boolean,\n" +
            "\t\temployeeIdTo int,\n" +
            "\t\tisInfectedTo boolean,\n" +
            "\t\tdayOfInfection int\n" +
            "\t)  AS \$\$\n" +
            "BEGIN\n" +
            "    return query\n" +
            "\tselect * from possibleContacts(it, c1, c2, endDay, r) as res\n" +
            "\twhere res.isInfectedTo = false;\n" +
            "END;\n" +
            "\$\$ LANGUAGE plpgsql;"

    const val FUNCTION_LIST_OF_INFECTIONS = "CREATE OR REPLACE FUNCTION listOfInfections(it int, endDay int, r int)\n" +
            "RETURNS table (\n" +
            "\t\temployeeFrom int,\n" +
            "\t\temployeeTo int,\n" +
            "\t\tdayInfection int\n" +
            "\t)  AS \$\$\n" +
            "BEGIN\n" +
            "\treturn query\n" +
            "\twith toInfect as (\n" +
            "    select employeeidfrom, employeeIdTo, dayOfInfection,\n" +
            "\trank () over (partition by employeeIdTo order by employeeIdFrom) infection_order\n" +
            "\t\tfrom\n" +
            "\t\t\t(\n" +
            "\t\t\t\t(with pc as (select employeeidfrom, isinfectedfrom, employeeidto, isinfectedto, dayofinfection,\n" +
            "\t\t\t\trank () over (partition by employeeIdfrom order by employeeIdto desc) contact_rank\n" +
            "\t\t\t\tfrom (\n" +
            "\t\t\t\t\tselect * from possibleContacts(it, 'id1', 'id2', endDay) as res\n" +
            "\t\t\t\t\tunion\n" +
            "\t\t\t\t\tselect * from possibleContacts(it, 'id2', 'id1', endDay) as res) as multipl)\n" +
            "\t\t\t\t\tselect employeeidfrom, isinfectedfrom, employeeidto, isinfectedto, dayofinfection from pc\n" +
            "\t\t\t\t\twhere contact_rank <= r\n" +
            "\t\t\t\t\torder by employeeidfrom, employeeidto)\n" +
            "\t\t\t\t\tintersect (\n" +
            "\t\t\t\t\t(select * from (select * from possibleContacts(it, 'id1', 'id2', endDay) as res\n" +
            "\t\t\t\t\tunion\n" +
            "\t\t\t\t\tselect * from possibleContacts(it, 'id2', 'id1', endDay) as res) as res2\n" +
            "\t\t\t\t\twhere isinfectedto = false\n" +
            "\t\t\t\t\torder by  employeeidto\n" +
            "\t\t\t\t\t)))\n" +
            "\t\tas listWithDuplicates)\n" +
            "\t\tselect employeeidfrom, employeeIdTo, dayOfInfection\n" +
            "\t\tfrom toInfect\n" +
            "\t\twhere infection_order = 1;\n" +
            "END;\n" +
            "\$\$ LANGUAGE plpgsql;"

    const val FUNCTION_INFECT = "CREATE OR REPLACE FUNCTION infect(it int, newIteration int, endDay int, r int)\n" +
            "RETURNS int AS \$\$\n" +
            "DECLARE\n" +
            "infectionsCount int;\n" +
            "BEGIN\n" +
            "\tdrop table if exists new_infections;\n" +
            "\tCREATE TEMP TABLE new_infections as\n" +
            "\tSELECT * FROM listOfInfections(it, endDay, r);\n" +
            "\n" +
            "\tinsert into Infections (infectionFrom, infectionTo, day)\n" +
            "               select employeeFrom, employeeTo, dayInfection from new_infections;\n" +
            "\n" +
            "\tupdate Employees set isInfected = true, iteration = newIteration where employeeId in (\n" +
            "\t\tselect employeeTo from new_infections);\n" +
            "\n" +
            "\tselect count(*) into infectionsCount from new_infections;\n" +
            "\n" +
            "\treturn infectionsCount;\n" +
            "END;\n" +
            "\$\$ LANGUAGE plpgsql;"

    const val QUERY_R_BASED_ON_ITERATION = "select iteration, avg(rep) from( select employeeId, iteration, count(infectionTo) as rep from Employees\n" +
            "left join Infections on infectionFrom = employeeId\n" +
            "where isInfected = true \n" +
            "group by employeeId\n" +
            "order by employeeId ) as infection_list\n" +
            "group by iteration"

    const val QUERY_FIND_COUNT_OF_INFECTED = "select count(*) from Employees where isInfected = true"
    val QUERY_DO_ITERATION = { iteration: Int, nextIteration: Int, day: Int, r: Int ->
        "select infect($iteration, $nextIteration, $day, $r)"
    }
    const val QUERY_ADD_INDEX_ON_EMPLOYEE_ID = "CREATE INDEX ON employees(employeeId);"
    const val QUERY_ADD_INDEX_ON_IS_INFECTED = "CREATE INDEX ON employees(isInfected);"
    const val QUERY_MAX_ITERATION = "select max(iteration) from Employees"
}